<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. tests, examples), we assume the server is started with
    'grunt depserve' (or similar server setup) to enable correct finding of bower dependencies for local runs.
-->
<link rel="import" href="../polymer/polymer.html" />
<link rel="import" href="../px-clipboard/px-clipboard.html" />
<link rel="import" href="../prism-element/prism-highlighter.html" />




<!--
px-demo-snippet is a helper element that displays the un-rendered code of the component requested.

In addiction to element properties, you can also pass in light dom content, by including a "lightDomContent" property in the corresponding object inside elementProperties

##### Usage

    <px-demo-snippet
      element-properties={{elemProps}}
      element-name="px-dropdown">
    </px-demo-snippet>

@element px-demo-snippet
@blurb px-demo-snippet is a helper element that displays the un-rendered code of the component requested.
@homepage index.html
@demo demo.html
-->
<dom-module id="px-demo-snippet">
  <link rel="import" type="css" href="css/px-demo-snippet.css"/>
  <template>
    <prism-highlighter></prism-highlighter>
    <div class="flex demoCode">
      <div class="editor u-mr+ u-p-">
        <div id="jeditor"></div>
      </div>
      <div class="clipboard u-pr+ u-pt-">
        <px-clipboard data-clipboard-text="[[_output]]"></px-clipboard>
      </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({

    is: 'px-demo-snippet',

    /**
     * Properties block, expose attribute values to the DOM via 'notify'
     *
     * @property properties
     * @type Object
     */
    properties: {
      /**
       * A property that holds the name of the component
       * for which we are displaying the source
       *
       * @property elementName
       * @type String
       */
      elementName: {
        type: String,
        value: '',
      },
      /**
       * An object that holds all the properties for the element
       * for which we are displaying the source
       *
       * @property elementProperties
       * @type Object
       */
      elementProperties: {
        type: Object
      },
      /**
       * An object that holds a reference to the component
       * for which we are displaying the source
       *
       * @property _demoElement
       * @type Object
       */
      _demoElement: {
        type: Object
      },
      /**
       * A string - that is created dynamically by the options selected on the page -
       * that reflects the unrendered component code
       *
       * @property _demoElement
       * @type Object
       */
      _output : {
        type: String,
        notify: true,
        observer: '_render'
      }
    },
    observers: ['_elementPropertyChanged(elementProperties.*)', '_setPropertyChanger(elementName)'],
    attached: function() {
      //first, make sure to find the component we are doing the demo on
      this._findDemoElement();
      this._formatComponentString();
    },
    _render: function() {
      var  output = this._fireOutputEvent(this._output, 'html');

      if (output.substr(0, 5) !== '<span') {
        //prism highlighter hasn't loaded yet. run this again with async.
        this.async(this._render, 0);
      } else {
        this.$.jeditor.innerHTML = output;
      }
    },
    /**
    *
    * This method fires a syntax-highlight event (meant for prism-highlighter), and returns the code, with formatting.
    *
    * @method _fireOutputEvent
    * @return {Highlighted Code}
    */
    _fireOutputEvent: function(code, lang) {
      //this fires an event that is changed through prism-element.
      return this.fire('syntax-highlight', {code: code, lang: lang}).detail.code;
    },
    /**
    * This method is called through the deep observer, whenever a property is changed
    * by the user. it calls _setPropertyChanger and _formatComponentString.
    *
    * @method _elementPropertyChanged
    */
    _elementPropertyChanged: function(changeRecord) {
      var prop = changeRecord.path,
          value = changeRecord.value;
      prop = prop.substr( prop.indexOf('.') + 1 );
      this._setPropertyChanger(prop, value);
      this._formatComponentString();
    },
    /**
    * This method searches the document for the component demoed.
    * and sets a reference in _demoElement to that component.
    *
    * @method _findDemoElement
    */
    _findDemoElement: function() {
      //find the demo component
      var demoElem = document.querySelector(this.elementName);
      if (demoElem) { //and if it's there, set it inside _demoElement
        this._demoElement = demoElem;
      }
    },
    /**
    * This method searches the document for the component demoed.
    * and sets a reference in _demoElement to that component.
    *
    * @method _setPropertyChanger
    */
    /**
    * This event is fired when a property is changed by the user.
    *
    * @event pxDemoPropertyChanged
    */
    _setPropertyChanger: function(prop, value) {
      if (this._demoElement) { //make sure the component exists, and if so, call Polymer set directly on it.
        this._demoElement.set(prop, value);
        // and fire an event.
        this.fire('pxDemoPropertyChanged', {"property" : prop, "value": value});
      }
    },
    /**
    * This method formats the string which is the unrendered code for the component
    * we are domoing
    *
    * @method _formatComponentString
    */
    _formatComponentString: function() {
      //define our opening string with an opening <
      var result = '<' + this.elementName,
          value,
          lightDomContent;
      // and loop through all the properties passed to us.
      for (var prop in this.elementProperties) {
        var singleQuotes = false;
        value = this.elementProperties[prop];
        if (value && prop !== "lightDomContent") { //check that value is there AND is NOT false. false attributes should NOT be passed
          if (typeof value === "object") { //if the passed value is an object, we have to stringify it, or else it shows [OBJECT OBJECT]
            value = JSON.stringify(value);
            singleQuotes = true;
          } else if (Array.isArray(value)) {
            singleQuotes = true;
          }
          //we are using the built in Polymer method of converting CamelCase to dashes-case, since the properties handed to us must be CamelCase.
          result += ' ' + Polymer.CaseMap.camelToDashCase(prop) +
          ((singleQuotes) ? '=\'' :  '="') + value + ((singleQuotes) ? '\'' :  '"');
        } else if (prop === "lightDomContent") {
          lightDomContent = value; //save the value to insert later - we have to close the tag first, and the order is never guaranteed with a for in loop.
        }
      }
      //close off our string
      result += '>';
      //check if we have any light dom content, and if so, insert it to the string.
      if (lightDomContent) { //if we have a light dom content, insert it now
        result += lightDomContent;
        lightDomContent = ''; //and empty it, just to be safe.
      }
      result += '</' + this.elementName + '>';
      //and set _output, using data binding to pass it into ace widget and px-clipboard
      this.set('_output',result);
    }
  });
</script>
